# java 相关

## 线程池

### 1.如果可运行的线程数量多于可用处理器的数量的后果：
	有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销
	JVM在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括JVM的启动参数、Thread构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError异常。
### 2.线程池原理：
	有一个队列，任务会被提交到这个队列中。一定数量的线程会从该队列中取出任务，然后执行。任务的结果可以发回客户端、可以写入数据库、也可以存储到内部数据结构中，等等。但是任务执行完成后，这个线程会返回任务队列，检索另一个任务并执行。
### 3.一个线程池中的线程异常了，那么线程池会怎么处理这个线程?
	当执行方式是execute时,可以看到堆栈异常的输出。
	当执行方式是submit时,堆栈异常没有输出。但是调用Future.get()方法时，可以捕获到异常。
	不会影响线程池里面其他线程的正常执行。线程池会把这个线程移除掉，并创建一个新的线程放到线程池中。
### 4.阿里开发规范为什么不允许Executors快速创建线程池？
	在 workQueue 参数直接 使用了 new LinkedBlockingQueue<Runnable>() 理论上可以无限添加任务到线程池。工作机制是，固定了N个线程，而提交给线程池的任务队列是不限制大小的，如果被阻塞或者变慢，那么显然队列里面的内容会越来越多,造成内存泄漏，最终导致OOM。
	正确姿势：
	private static ExecutorService executor = new ThreadPoolExecutor(10, 10,
        60L, TimeUnit.SECONDS,
        new ArrayBlockingQueue(10));

