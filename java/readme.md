# java 相关

## 线程池

### 1.如果可运行的线程数量多于可用处理器的数量的后果：
	有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销
	JVM在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括JVM的启动参数、Thread构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError异常。
### 2.线程池原理：
	有一个队列，任务会被提交到这个队列中。一定数量的线程会从该队列中取出任务，然后执行。任务的结果可以发回客户端、可以写入数据库、也可以存储到内部数据结构中，等等。但是任务执行完成后，这个线程会返回任务队列，检索另一个任务并执行。
### 3.一个线程池中的线程异常了，那么线程池会怎么处理这个线程?
	当执行方式是execute时,可以看到堆栈异常的输出。
	当执行方式是submit时,堆栈异常没有输出。但是调用Future.get()方法时，可以捕获到异常。
	不会影响线程池里面其他线程的正常执行。线程池会把这个线程移除掉，并创建一个新的线程放到线程池中。
### 4.阿里开发规范为什么不允许Executors快速创建线程池？
	在 workQueue 参数直接 使用了 new LinkedBlockingQueue<Runnable>() 理论上可以无限添加任务到线程池。工作机制是，固定了N个线程，而提交给线程池的任务队列是不限制大小的，如果被阻塞或者变慢，那么显然队列里面的内容会越来越多,造成内存泄漏，最终导致OOM。
	正确姿势：
	private static ExecutorService executor = new ThreadPoolExecutor(10, 10,
        60L, TimeUnit.SECONDS,
        new ArrayBlockingQueue(10));

## SpringBoot
### SpringBoot 自动装配过程:
    1.SpringApplication启动
    2.new SpringApplication() 构建一个Spring应用
    3.initialize 初始化模块
    3.a 配置source
    3.b 配置是否为web环境
    3.c 创建初始化构造器 （重要）
    3.d 创建应用监听器 （重要）
    3.e 配置引用的主方法所在类
    
    4.获取构造器（工厂）对象
    5.得到所需工厂集合的实例
    6.获取传入的工厂类名，类加载器
    7.通过类加载器，获取指定的spring.factories文件
    8.获取文件中工厂类的全路径
    9.通过类路径反射得到工厂的class对象，构造方法
    10.生成工厂类实例，返回
    
    11.启动应用监听器
    12.应用启动计时器开始计时，应用启动监听器开始监听（headless模式配置）
    13.启动SpringApplicationRunListeners 
    14.监听内容为 配置环境，应用上下文等
    15.配置环境模块ConfigurableEnvironment 配置环境模块
    16.创建配置环境（web/noweb）
    17.加载属性文件资源
    18.配置监听
     
    19.应用上下文模块 ConfigurableApplicationContext
    20.创建应用上下文 (web/noweb)，基本属性配置，更新应用上下文
    21.加载配置环境，ResourceLoader资源管理器，配置监听，加载启动参数
    22.准备环境所需的bean工厂（从10获取到的）
    23.通过工厂产生环境所需的bean
    24.应用启动计时器开始计时，应用启动监听器开始监听
    25.结束

### 多线程编程    
    问题：
    多线程编程
    当多个高并发线程都需要等待一个非常重量级的任务（比如网络请求或者数据库查询）返回的结果
    注：
    具体场景，数据库查询得到结果可以本地内存缓存起来，但在缓存为空的情况下，并发第一次访问可能会引起多次数据库请求
    要求：1，避免每个线程并发性的去多次重复计算任务
    
    思路：
    一种可能的方案为：
    在取数据时加锁，综合QPS和RT的情况下，考虑使用synchronized 或 ReentrantLock 对同步资源加锁，
    这里的加锁之后需要double check缓存情况，如果缓存有数据直接返回，这里是为了防止其他线程已经更新完毕。
    加锁时，可以使用ReentrantLock（非公平） tryLock来获取，没有获取到锁时，当前线程自旋等待，并读取缓存，如果都失败
    则获取mysql，更新缓存。
    可优化点：
    1.如果发现多个id在数据库中均不存在，可以考虑维护一个不存在id的cache，数据库更新之后，异步更新这个cache。
    2.线程很多时，会有大量的while循环 占用过多的cpu，如1个线程获取到锁，9个线程在自旋读cache。
    a.在允许空结果的情况下可以在指定时间后直接fail请求，减少cpu压力
    b.如果不允许空结果，考虑将一部分线程LockSupport.park()，在获取到值之后unpark()
    3.使用Offheap等堆外cache，减少gc压力