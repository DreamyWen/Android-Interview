# java 相关

## 线程池

### 1.如果可运行的线程数量多于可用处理器的数量的后果：
	有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争CPU资源时还将产生其他性能的开销
	JVM在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括JVM的启动参数、Thread构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError异常。
### 2.线程池原理：
	有一个队列，任务会被提交到这个队列中。一定数量的线程会从该队列中取出任务，然后执行。任务的结果可以发回客户端、可以写入数据库、也可以存储到内部数据结构中，等等。但是任务执行完成后，这个线程会返回任务队列，检索另一个任务并执行。
### 3.一个线程池中的线程异常了，那么线程池会怎么处理这个线程?
	当执行方式是execute时,可以看到堆栈异常的输出。
	当执行方式是submit时,堆栈异常没有输出。但是调用Future.get()方法时，可以捕获到异常。
	不会影响线程池里面其他线程的正常执行。线程池会把这个线程移除掉，并创建一个新的线程放到线程池中。
### 4.阿里开发规范为什么不允许Executors快速创建线程池？
	在 workQueue 参数直接 使用了 new LinkedBlockingQueue<Runnable>() 理论上可以无限添加任务到线程池。工作机制是，固定了N个线程，而提交给线程池的任务队列是不限制大小的，如果被阻塞或者变慢，那么显然队列里面的内容会越来越多,造成内存泄漏，最终导致OOM。
	正确姿势：
	private static ExecutorService executor = new ThreadPoolExecutor(10, 10,
        60L, TimeUnit.SECONDS,
        new ArrayBlockingQueue(10));

## SpringBoot
### SpringBoot 自动装配过程:
    1.SpringApplication启动
    2.new SpringApplication() 构建一个Spring应用
    3.initialize 初始化模块
    3.a 配置source
    3.b 配置是否为web环境
    3.c 创建初始化构造器 （重要）
    3.d 创建应用监听器 （重要）
    3.e 配置引用的主方法所在类
    
    4.获取构造器（工厂）对象
    5.得到所需工厂集合的实例
    6.获取传入的工厂类名，类加载器
    7.通过类加载器，获取指定的spring.factories文件
    8.获取文件中工厂类的全路径
    9.通过类路径反射得到工厂的class对象，构造方法
    10.生成工厂类实例，返回
    
    11.启动应用监听器
    12.应用启动计时器开始计时，应用启动监听器开始监听（headless模式配置）
    13.启动SpringApplicationRunListeners 
    14.监听内容为 配置环境，应用上下文等
    15.配置环境模块ConfigurableEnvironment 配置环境模块
    16.创建配置环境（web/noweb）
    17.加载属性文件资源
    18.配置监听
     
    19.应用上下文模块 ConfigurableApplicationContext
    20.创建应用上下文 (web/noweb)，基本属性配置，更新应用上下文
    21.加载配置环境，ResourceLoader资源管理器，配置监听，加载启动参数
    22.准备环境所需的bean工厂（从10获取到的）
    23.通过工厂产生环境所需的bean
    24.应用启动计时器开始计时，应用启动监听器开始监听
    25.结束